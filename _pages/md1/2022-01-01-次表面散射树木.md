---
title: 《移植UE次表面散射树木光照模型》
author: DH Wang
date: 1000-01-01
category: TA
layout: post
---



# Title
这个光照模型是参考虚幻中的Foliage的散射算法进行自定义修改的。效果如下：


![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/11/29/foliage.png)


当前材质适用于绝大部分植被种类，用于渲染较薄的次表面散射材质，例如树叶、花瓣等。它可以模拟光线穿过材质的效果。新植被是建立在基础材质的效果上添加了新的功能（散射和AO以及抖动剔除），在不改动原有光照效果的基础上添加新植被特性相关的效果和功能，将散射强度和胶囊体AO范围降低即可还原基础材质表现效果。

# 消隐处理
消隐处理就是当斜着看向植物面片时会抖动裁剪掉斜率过大的部分，使树木更真实，这里参考了SpeedTree中的计算方式(speedtree是个专门做树木的软件十分逼真，而且也官方集成在了u3d中所以可以适当借鉴)，关键代码如下：

```
float SpeedTreeCliping(float3 Normal,bool topDown)
{
    float3 treePos = float3(UNITY_MATRIX_M[0].w, UNITY_MATRIX_M[1].w, UNITY_MATRIX_M[2].w);
    float3 viewDir = UNITY_MATRIX_IT_MV[2].xyz;
    float3 cameraDir = normalize(mul((float3x3)UNITY_MATRIX_M, _WorldSpaceCameraPos - treePos));
    float viewDot = max(dot(viewDir, Normal), dot(cameraDir, Normal));
    viewDot *= viewDot;
    viewDot *= viewDot;
    viewDot += topDown ? 0.38 : 0.18; // different scales for horz and vert billboards to fix transition zone

    // if invisible, avoid overdraw
    // if (viewDot < 0.3333)
    // {
    // input.vertex.xyz = float3(0, 0, 0);
    // }

    return clamp(viewDot, 0, 1); 
}

//消隐处理
#if LOD_FADE_CROSSFADE_ON  
    float SpTreeClip = SpeedTreeCliping(FaceNormal,true)*BaseColor.a;
    clip(SpTreeClip - 0.333 );
    float ClipLeaf =1-abs(dot(viewDir,FaceNormal));
    ClipLeaf = saturate((1-ClipLeaf)*5-1) ;
    LODDitheringTransition(i.pos.xy,ClipLeaf);   
#else
    clip(BaseColor.a-_Cutoff);
#endif
```

虚幻中处理一些效果时基本都会结合抖动因为配合上一帧数据可以让整体画面更平顺稳定，看起来更真实，这里也是使用了抖动算法来处理消隐。

# AO部分

树木渲染的阴影部分也很重要这是体现整体色调的一个关键因素，一版树木的AO是体现在树干部分所以这里使用预烘焙顶点色来传递AO信息，但是使用传统的光能传递来烘焙AO并不是很好控制，当然制作模型也可以使用Houdini不过学习成本比较高，这里简单写了个maxscript插件来处理顶点色。

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/11/29/maxcc.png)

max脚本的语法上也是类C的所以上手也比较容易大部分特性和Lua基本上差不多类似，也可以直接在官网查询API（相比SP强大多了）。

最后实现的效果：

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/11/29/foliage.gif)
