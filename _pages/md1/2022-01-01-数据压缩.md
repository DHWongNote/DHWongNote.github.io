---
title: 《数据压缩》
author: DH Wang
date: 1000-01-01
category: TA
layout: post
---

# 数据压缩

## 
```
#if HIGH_PRECISION 
const int PRECISION = 64;
#else
const int PRECISION = 8;
#endif


half4 unpack(float value)
{   
    half4 color;

    color.a = value % PRECISION;
    value = floor(value / PRECISION);

    color.b = value % PRECISION;
    value = floor(value / PRECISION);

    color.g = value % PRECISION;
    value = floor(value / PRECISION);

    color.r = value;

    return color / (PRECISION - 1);
}

float pack(half4 color)
{   
    int4 iVal = floor(color * (PRECISION - 1));

    float output = 0;

    output += iVal.r * PRECISION * PRECISION * PRECISION;
    output += iVal.g * PRECISION * PRECISION;
    output += iVal.b * PRECISION;
    output += iVal.a;

    return output;
}

```




## float -> vec4 ->float
```
vec4 packFloatToRgba(float _value)
{
    const vec4 shift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);
    const vec4 mask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
    vec4 comp = fract(_value * shift);
    comp -= comp.xxyz * mask;
    return comp;
}

float unpackRgbaToFloat(vec4 _rgba)
{
    const vec4 shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
    return dot(_rgba, shift);
}
```


```
inline float4 EncodeFloatRGBA( float v ) {
  float4 enc = float4(1.0, 255.0, 65025.0, 16581375.0) * v;
  enc = frac(enc);
  enc -= enc.yzww * float4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
  return enc;
}
inline float DecodeFloatRGBA( float4 rgba ) {
  return dot( rgba, float4(1.0, 1/255.0, 1/65025.0, 1/16581375.0) );
}
```

## float -> vec3 ->float
```
vec3 packFloatToRgb(float _value)
{
    const vec3 shift = vec3(256 * 256, 256, 1.0);
    const vec3 mask = vec3(0, 1.0 / 256.0, 1.0 / 256.0);
    vec3 comp = fract(_value * shift);
    comp -= comp.xxy * mask;
    return comp;
}

float unpackRgbToFloat(vec3 _rgb)
{
    const vec3 shift = vec3(1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
    return dot(_rgb, shift);
}

```

## vec4 -> float -> half2
```
float unpackRgbaToFloat(vec4 _rgba)
{
    const vec4 shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
    return dot(_rgba, shift);
}

vec2 packHalfFloat(float _value)
{
    const vec2 shift = vec2(256, 1.0);
    const vec2 mask = vec2(0, 1.0 / 256.0);
    vec2 comp = fract(_value * shift);
    comp -= comp.xx * mask;
    return comp;
}
```

## uint -> vec4 ->uint
```
vec4 convRGBA8ToVec4( in uint val )
{
    return vec4( float( (val&0x000000FF) ), float( (val&0x0000FF00)>>8U),
                 float( (val&0x00FF0000)>>16U), float( (val&0xFF000000)>>24U) );
}

uint convVec4ToRGBA8( in vec4 val )
{
    return ( uint(val.w)&0x000000FF)<<24U | (uint(val.z)&0x000000FF)<<16U | (uint(val.y)&0x000000FF)<<8U | (uint(val.x)&0x000000FF);
}
```
## float2->flaot-float2

```
float decode2half(float2 c) {
	float high = c.x * 255;
	float sign = floor(high / 128);
	high -= sign * 128;
	sign = 1 - 2 * sign;
	float exp = floor(high / 4) - 15;
	float mantissa = c.y * 255 + high % 2 * 256 + floor(high / 2 % 2) * 512;
	return sign * pow(2, exp) * (1 + mantissa / 1024);
}



```
