---
title: 《简易体积光射灯光柱》
author: DH Wang
date: 1000-01-01
category: TA
layout: post
---

# Title


![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/22/5/17/Vlight.png)

2D面片射灯效果是通过Billboard方式和调整顶点位置来控制最终效果。具体形态可以实现为圆弧状和扇形（底部打平），参考示例如下：

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/22/5/17/1.png)

## 模型要求:
射灯的模型需要做特殊设置，因为扇形轨迹是通过顶点色来控制的形状变化。
先用max提供的基础平面模型Plane设置长宽分段为1后再设置顶点色。
参考示例图如下：

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/22/5/17/2.png)

面数的差异体现在顶部和角度过大时（参考图示如下），同时利用好面数和角度的关系可减少重复绘制,当开口角度过大时插值效果越明显，当顶部衰减越强时顶部的块状效果也越明显。总而言之模型是表现射灯的载体，而最终效果需要通过模型来调节相应的射灯范围。

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/22/5/17/3.png)


因为是使用面片来模拟灯柱所以消耗十分小，效果调节得当还可以用来模拟体积光柱，其关键代码如下：

```
//一套UV只能保存1个二维数据，当前效果需要三维数据所以索性采样顶点色计算
Shader "Unlit/VBL"
{
    Properties
    { 
 
[Space(10)]
        [HDR]_Color("Color",Color)=(1,1,1,1)
        _DistanceAttenuation("DistanceAttenuation",float)=1
[Space(10)] 
        _LightRange("Light top Range",float)=5
        _LightOffset("Light bottom Offset",float)=0.2
        _LightSpread("Light Spread",Range(0.1,1))=0.5
        // _NoiseTex ("Dust Noise", 2D) = "white" {}

[Space(100)]
        [Toggle]showModel("------------------ShowModel-----------------",float)=0
[Space(10)]
        _Radius("UP Radius",Range(0,20))=5
        _Degree("UP Degree",Range(0,180))=30

[Space(10)]
        _Radius1("Down Radius",Range(0,20))=0
        _Degree1("Down Degree",Range(0,180))=0
        [Toggle]FlatDownBoard("FlatDownBoard",float)=1
        _FlatXFactor("FlatXFactor",float)=0.2
        // _OffSet("Offset Z",Range(-10,10))=00
        
[Space(10)]
        [Toggle]EnableBillBoard("BillBoard",float)=0
		_VerticalBillboarding ("Vertical Restraints", Range(0, 1)) = 1 
    }
    SubShader
    {
        Tags
        {
            "Queue" = "Transparent"
            "RenderType" = "Transparent"
            "IgnoreProjector" = "True"
            "DisableBatching" = "True" 
        }
        Blend SrcAlpha One  //Light Setting
        ZWrite Off
        Cull Back


        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag 
            #pragma multi_compile_fog 
            #include "UnityCG.cginc" 
            
            #define DEGTRAD 0.01745329;         //degree to rad
            // #define PI 3.14159265
            // #define OSLIGHTFORWARD float3(0,1,0)//模型空间下光源的正方向
            

            struct appdata
            {  
                float3 color : COLOR;           //r:Up g:Attenuation b:Down
                float4 vertex : POSITION;


                // float2 uv : TEXCOORD0;
                // float2 uv1 : TEXCOORD1; 
            };

            struct v2f
            { 
                UNITY_FOG_COORDS(1)    
                float4 color        : COLOR;        //rgb:可做动态颜色变化 a:衰减系数
                float4 vertex       : SV_POSITION;
                float2 preUV        : TEXCOORD0;   
                float3 worldPos     : TEXCOORD1;  
                float4 screen_space : TEXCOORD2;

                // float2 uv           : TEXCOORD3;
                // float3 preNormal    : TEXCOORD4;   
            };
             


            float _Radius;
            float _Degree;
            float _Radius1;
            float _Degree1;
            float _OffSet;
            float _FlatXFactor;
            float EnableBillBoard;
            float FlatDownBoard;
            float _VerticalBillboarding;

            float showModel;
            float _LightOffset;
            float _LightRange;
            float _LightSpread;
            float _DistanceAttenuation;
            float4 _Color;  

            sampler2D _CameraDepthTexture;
            // sampler2D _NoiseTex; 
            // float4 _NoiseTex_ST;


            v2f vert (appdata v)
            {
                v2f o; 
                float3 povit    = float3(0, 0, 0);//轴心模型空间原点center;
				float3 center   = float3(0, 0, 0);//轴心模型空间原点center;
                float2 preUV = float2(0, 0);//计算UV
                float3 VertexOS = v.vertex.xyz;
                float  up2down  =1-v.color.g;// VertexOS.x+VertexOS.y+VertexOS.z; 
				float3 viewer           = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));
                // float3 povitPositionWS  = mul(unity_ObjectToWorld, float4(povit,1)).xyz; 
                // float3 WorldlightDir    = mul(unity_ObjectToWorld, float4(OSLIGHTFORWARD-povit,1)).xyz; 
                


// 顶点色/（Tex_Lod）计算扇形区域//////////////////////////////////////////////////////////////////////////////////////////////// 
                float angleRad  = DEGTRAD;  angleRad  *= _Degree;
                float angleRad1 = DEGTRAD;  angleRad1 *= _Degree1;
                // float angleCur  = angleRad*(v.uv1.x-0.5);
                //float angleCur1 = angleRad1*(v.uv1.y-0.5);
                float angleCur  = angleRad*(v.color.r-0.5); 
                float angleCur1 = angleRad1*(v.color.b-0.5);
                
                float cosA = cos(angleCur);
                float sinA = sin(angleCur);
                float3 NewVertexOS  =float3( _Radius * sinA , _Radius * cosA, _OffSet);
                
                float cosB = cos(angleCur1);
                float sinB = sin(angleCur1); 
                float3 NewVertexOS1 =float3( _Radius1 * sinB, _Radius1 * cosB, _OffSet);
                NewVertexOS1 =lerp(NewVertexOS1,float3(_FlatXFactor*(v.color.b-0.5), center.y, _OffSet),FlatDownBoard);
                 
                VertexOS =lerp(NewVertexOS1, NewVertexOS,up2down);   
                 
                preUV = float2(VertexOS.xy);


// BillBoard//////////////////////////////////////////////////////////////////////////////////////////////// 
                float3 normalDir = viewer - center;
				// 如果_VerticalBillboarding等于1，视图方向作为正常方向，如果_VerticalBillboarding等于0，则法线的y为0
				normalDir.y =normalDir.y * _VerticalBillboarding;
				normalDir = normalize(normalDir);
                ////获取近似的上方向，如果正常方向已经朝向上方，则上方方向朝向前方
				float3 upDir = abs(normalDir.y) > 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);
				float3 rightDir = normalize(cross(upDir, normalDir));
				upDir = normalize(cross(normalDir, rightDir)); 
				float3 centerOffs = VertexOS - center;
				float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;
               
                VertexOS =lerp( VertexOS,localPos,EnableBillBoard);
                  
// Light Gradient//////////////////////////////////////////////////////////////////////////////////////////////// 
                // Gradient noise from Jorge Jimenez's presentation:
                // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare
                //根据世界位置设置Factor  
                float3 magic = float3(0.06711056, 0.00583715, 52.9829189); 
                magic =  frac(magic.z * frac(dot( VertexOS,magic))); 
                magic = abs(  float3(sin(_Time.y),cos(_Time.y),sin(_Time.y))   );
 
// Init Data//////////////////////////////////////////////////////////////////////////////////////////////// 
                // o.uv = v.uv;  
                   
                o.preUV = preUV;
                o.worldPos = mul(unity_ObjectToWorld,VertexOS);
                o.vertex = UnityObjectToClipPos(VertexOS); 
                o.color  = float4( magic, v.color.g);  
                o.screen_space = ComputeScreenPos(o.vertex); // lsc 计算屏幕空间 xy为屏幕坐标, z为视深
                COMPUTE_EYEDEPTH(o.screen_space.z);   
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }
          
            half4 frag (v2f i) : SV_Target
            {       


// Compute UV//////////////////////////////////////////////////////////////////////////////////////////////// 
                //////////////////////////////////////////////////////////////////
                //     x = -7.000000, y = 7.000000 的反正切ret是 135.000000 度   //
                //     {                                                        //
                //        #define PI 3.14159265                                 //
                //        double ret, val;                                      //
                //        val = 180.0 / PI;                                     //
                //        ret = atan2 (y,x) * val;                              //
                //     }                                                        //
                //////////////////////////////////////////////////////////////////  
 
                float atan2Y = i.preUV.x*_LightRange;
                float atan2X = i.preUV.y+_LightOffset;

                float computeUVX =saturate( 1 - abs(atan2(atan2Y,atan2X)));
                computeUVX = smoothstep(0,_LightSpread,computeUVX);// pow(computeUVX,_LightSpread);
        
         
// Dust And Light Attenuation//////////////////////////////////////////////////////////////////////////////////////////////// 
                 
                half4 col =computeUVX*_Color; 
                // col.rgb *= i.color.rgb;

                // col.a = Remap(col.a);
                col.a *= pow(i.color.a,_DistanceAttenuation);
                col =lerp(col,1,showModel);
                return col;
    
// Soft Particle//////////////////////////////////////////////////////////////////////////////////////////////// 
              //
            }
            ENDHLSL
        }
    }
}

```

## 改进方向：
* 可在顶部范围采样一些噪波扰动图模拟穿透尘埃效果;

* 同时可以根据效果优化代码（删除一些不必要计算如默认开启billboard等开关，使用自定义remap函数代替pow，保留一种变换模式等等）;

* 如果实现跑马灯等色彩变化效果可以在顶点中根据轴心povit世界坐标取随机因子再跟随时间做色彩变化等....