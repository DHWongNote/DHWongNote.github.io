---
title: 《Python在UE中的简单应用》
author: DH Wang
date: 1000-01-01
category: TA
layout: post
---

# Python Bp C++互调

可通过蓝图来执行python脚本（Excute python）
  但注意，蓝图也是专门的蓝图类，需要是编辑器蓝图类（Editor Uitilites->Editor Uitilites BluePrint）

## 使用方式

1、使用Vscode打开/导入生成的Unreal.py/目录即可，也不用官网查API，
    如何生成unreal.py?
    Project Setting->Plugins-Python->Develper Mode(all Users)->restart


2、 插件：UnrealPython(弃用，不推荐：官方集成不够并不流行，有经验的大佬也不会使用该方法)https://github.com/20tab/UnrealEnginePython/releases?page=2
 UE Version <=4.22 
 Py Version <=3.7



## URL
```
官方介绍：https://docs.unrealengine.com/5.0/en-US/scripting-the-unreal-editor-using-python/

PythonAPI：https://docs.unrealengine.com/5.0/en-US/PythonAPI/
```





## 常用示例：Import Unreal.py

### 辅助计算
```
import unreal
v1 = unreal.Vector()
v1.x = 10
v2 = unreal.Vector(10, 20, 30)
v3 = (v1 + v2) * 2
print(v3)
```




### Log
```
unreal.log()  
unreal.log_warning() 
unreal.log_error()  
```

### 进度条
```
from time import sleep
import unreal 
total_frames = 100000
text_label = "Working!"
with unreal.ScopedSlowTask(total_frames, text_label) as slow_task:
    slow_task.make_dialog(True)               # Makes the dialog visible, if it isn't already
    print("Start process")
    for i in range(total_frames): 
        if slow_task.should_cancel():         # True if the user has pressed Cancel in the UI
            break
        slow_task.enter_progress_frame(1)     # Advance progress by one frame.
                                            # You can also update the dialog text in this call, if you want.
        ...                                   # Now do work for the current frame here!
        
    print("processed")
```




### Draft
```
# NOTE 生成临时材质
material = unreal.Material()
unlit = unreal.MaterialShadingModel.MSM_UNLIT
# NOTE 设置为 unlit 模式
material.set_editor_property("shading_model", unlit)

# NOTE 生成顶点色节点 位置为 0,0 
vertex_color = unreal.MaterialEditingLibrary.create_material_expression(
    material,unreal.MaterialExpressionVertexColor)

# NOTE 将顶点色节点的 R 通道和 emissive 属性相连
emissive = unreal.MaterialProperty.MP_EMISSIVE_COLOR
unreal.MaterialEditingLibrary.connect_material_property(vertex_color, "R", emissive)
# NOTE 编译材质
unreal.MaterialEditingLibrary.recompile_material(material)

# NOTE 将临时材质赋予到选择模型的 StatiMeshComponent 上
static_comp.set_editor_property("override_materials",[material])

# NOTE 设置 Bake 属性
option = unreal.MaterialOptions()
option.set_editor_property("use_mesh_data", True)

properties = unreal.PropertyEntry()
MP_EMISSIVE_COLOR = unreal.MaterialProperty.MP_EMISSIVE_COLOR
properties.set_editor_property("property_", MP_EMISSIVE_COLOR)
option.set_editor_property("properties", [properties])

# NOTE 获取 Gui 上的输入的贴图大小
x = self.Tex_Size_X_SP.value()
y = self.Tex_Size_Y_SP.value()
size = unreal.IntPoint(x, y)
option.set_editor_property("texture_size", size)

# NOTE 通过 Editor Tests 插件提供的蓝图 bake 出材质和贴图 
unreal.EditorTestsUtilityLibrary.bake_materials_for_component(
    static_comp, option, unreal.MaterialMergeOptions())

# NOTE 获取Bake出来的 材质 | 从材质上获取生成的目标贴图
material = static_comp.get_editor_property("override_materials")[0]
texture = material.get_texture_parameter_value("EmissiveColorTexture")


# NOTE 导出 TGA 图片 | 方便 顶点色 导入
asset_tool = unreal.AssetToolsHelpers.get_asset_tools()
# NOTE 输出到临时路径上
texture_path = os.path.join(tempfile.gettempdir(),"Unreal_temp",name+"_BakeTexture.tga")
task = unreal.AssetExportTask()
task.set_editor_property('automated', True)
task.set_editor_property('filename', texture_path)
task.set_editor_property('object', texture)
task.set_editor_property('prompt', False)
task.set_editor_property('exporter', unreal.TextureExporterTGA())

check = unreal.Exporter.run_asset_export_task(task)
if not check:
    alert(u"tga 图片生成失败")
    return

# NOTE 等待贴图生成
time.sleep(1)

# NOTE https://forums.unrealengine.com/development-discussion/python-scripting/1608720-python-scripting-for-importing-custom-assets
# NOTE 导入贴图
task = unreal.AssetImportTask()
task.set_editor_property('automated', True)
task.set_editor_property('destination_name', name + '_BakeTexture')
task.set_editor_property('destination_path', path)
task.set_editor_property('filename', texture_path)
task.set_editor_property('replace_existing', True)
task.set_editor_property('save', True)
asset_tool.import_asset_tasks([task])

bake_path = path  + "/" +  name + '_BakeTexture'
texture = unreal.EditorAssetLibrary.load_asset(bake_path)
```


### 批量渲染Sequence
```
# -*- coding: utf-8 -*-
"""
渲染 sequencer 的画面
选择 LevelSequence 批量进行渲染
"""

from __future__ import division
from __future__ import print_function
from __future__ import absolute_import

__author__ = 'timmyliang'
__email__ = '820472580@qq.com'
__date__ = '2020-07-14 21:57:32'

import unreal

import os
import subprocess
from functools import partial

def alert(msg):
    unreal.SystemLibrary.print_string(None,msg,text_color=[255,255,255,255])

def render(sequence_list,i,output_directory="C:/render",output_format="{sequence}"):
    
    # NOTE 如果超出数组则退出执行
    if i >= len(sequence_list):
        # NOTE 输出完成 打开输出文件夹的路径
        subprocess.call(["start","",output_directory], creationflags=0x08000000,shell=True)
        return

    # NOTE 获取当前渲染序号下的 LevelSequence
    sequence = sequence_list[i]

    # NOTE 配置渲染参数
    settings = unreal.MovieSceneCaptureSettings()
    path = unreal.DirectoryPath(output_directory)
    settings.set_editor_property("output_directory",path)
    settings.set_editor_property("output_format",output_format)
    settings.set_editor_property("overwrite_existing",True)
    settings.set_editor_property("game_mode_override",None)
    settings.set_editor_property("use_relative_frame_numbers",False)
    settings.set_editor_property("handle_frames",0)
    settings.set_editor_property("zero_pad_frame_numbers",4)
    settings.set_editor_property("use_custom_frame_rate",True)
    settings.set_editor_property("custom_frame_rate",unreal.FrameRate(24, 1))

    # NOTE 渲染大小
    w,h = 1280,720
    settings.set_editor_property("resolution",unreal.CaptureResolution(w,h))
    
    settings.set_editor_property("enable_texture_streaming",False)
    settings.set_editor_property("cinematic_engine_scalability",True)
    settings.set_editor_property("cinematic_mode",True)
    settings.set_editor_property("allow_movement",False)
    settings.set_editor_property("allow_turning",False)
    settings.set_editor_property("show_player",False)
    settings.set_editor_property("show_hud",False)

    # NOTE 设置默认的自动渲染参数
    option = unreal.AutomatedLevelSequenceCapture()
    option.set_editor_property("use_separate_process",False)
    option.set_editor_property("close_editor_when_capture_starts",False)
    option.set_editor_property("additional_command_line_arguments","-NOSCREENMESSAGES")
    option.set_editor_property("inherited_command_line_arguments","")
    option.set_editor_property("use_custom_start_frame",False)
    option.set_editor_property("use_custom_end_frame",False)
    option.set_editor_property("warm_up_frame_count",0.0)
    option.set_editor_property("delay_before_warm_up",0)
    option.set_editor_property("delay_before_shot_warm_up",0.0)
    option.set_editor_property("write_edit_decision_list",True)
    # option.set_editor_property("custom_start_frame",unreal.FrameNumber(0))
    # option.set_editor_property("custom_end_frame",unreal.FrameNumber(0))
        
    option.set_editor_property("settings",settings)
    option.set_editor_property("level_sequence_asset",unreal.SoftObjectPath(sequence.get_path_name()))

    # NOTE 设置自定义渲染参数
    option.set_image_capture_protocol_type(unreal.CompositionGraphCaptureProtocol)
    protocol = option.get_image_capture_protocol()
    # NOTE 这里设置 Base Color 渲染 Base Color 通道，可以根据输出的 UI 设置数组名称
    passes = unreal.CompositionGraphCapturePasses(["Base Color"])
    protocol.set_editor_property("include_render_passes",passes)
    # protocol.set_editor_property("compression_quality",100)

    # NOTE 设置全局变量才起作用！
    global on_finished_callback
    on_finished_callback = unreal.OnRenderMovieStopped(
        lambda s:render(sequence_list,i+1,output_directory,output_format))
    unreal.SequencerTools.render_movie(option,on_finished_callback)
    

def main(output_directory="C:/render",output_format="{sequence}"):
    # NOTE 获取当前选择的 LevelSequence
    sequence_list = [asset for asset in unreal.EditorUtilityLibrary.get_selected_assets() if isinstance(asset,unreal.LevelSequence)]

    if not sequence_list:
        alert(u"请选择一个 LevelSequence")
        return

    if not os.access(output_directory, os.W_OK):
        alert(u"当前输出路径非法")
        return
    elif not os.path.exists(output_directory):
        # NOTE 路径不存在则创建文件夹
        os.makedirs(output_directory)
    elif os.path.isfile(output_directory):
        # NOTE 如果传入文件路径则获取目录
        output_directory = os.path.dirname(output_directory)

    render(sequence_list,0,output_directory,output_format)


if __name__ == "__main__":
    main()
```

# C++