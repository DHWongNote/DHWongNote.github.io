---
title: 《unity常用多Pass数据传输自定义SSSS为例》
author: DH Wang
date: 1000-01-01
category: TA
layout: post
---

在unity中有一些特殊效果是需要多个pass来共同完成数据计算，例如一些效果需要prepass来提供一些深度信息或法线等（SSAO），不同于延迟管线前向渲染没有一些基于屏幕存在的Buffer数据，所以想要在前向中实现一些基于屏幕信息的特殊效果就需要多个pass来共同完成。

下面结合次表面散射效果为例来探索如何在多个pass中完成一些数据的传输，次表面散射效果也分很多种方式（https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering），下面以最常用的一种来演示即可分离的次表面散射，虚幻中集成的次表面散射也是采用的这种方式不过对其中的卷积算法做了一些高效能的优化措施。
# 什么是可分离的次表面散射（Separable Subsurface Scattering）
从效果出发来模拟光线次表面散射，不是基于数学推导和物理正确的，
 
最初是由动视暴雪于2013年首先应用的技术，2年后他们把这种技术写成论文，称作Separable Subsurface Scattering，可以叫它4S技术。它也是一种基于屏幕空间模糊的技术，不过相比于之前的屏幕空间技术，它大大降低了消耗。原来的技术需要6次高斯模糊，而一次模糊需要x，y方向都做一个pass，6次就要12个pass来满足需要。现在4S技术只需要2个pass来做模糊，所以成为了现在游戏业界的主流技术.


主要原理：对光线辐射度纹理进行一次二维卷积运算（具体实现拆分为了两次一维运算，即对横向和纵向分别进行模糊），卷积运算的关键在于卷积核的算法，这里直接参考网上常用的一种（https://github.com/iryoku/separable-sss)除此还有其他的卷积核算法如：
* 高斯和函数的卷积核（TSD提出）
* 基于SVD分解的可分一维卷积核
* 预积分卷积核（类似LUT图）
* 艺术家易用的卷积核（基于两个高斯函数相加后相乘）
* 增加引导函数的可分一维卷积核


关于核函数的数学推导部分就省略了叭，计算核函数的代码CPP代码翻译C#如下：
```
 public static class SeparableSSS
    {
        public static void CalculateKernel(List<Vector4> kernel, int nSamples, Vector3 strength, Vector3 falloff)
        {
            float RANGE = nSamples > 20 ? 3.0f : 2.0f;
            float EXPONENT = 2.0f;
            kernel.Clear();

            // Calculate the offsets:
            float step = 2.0f * RANGE / (nSamples - 1);
            for (int i = 0; i < nSamples; i++)
            {
                float o = -RANGE + (float)i * step;
                float sign = o < 0.0f ? -1.0f : 1.0f;
                float w = RANGE * sign * Mathf.Abs(Mathf.Pow(o, EXPONENT)) / Mathf.Pow(RANGE, EXPONENT);
                kernel.Add(new Vector4(0, 0, 0, w));
            }
            // Calculate the weights:
            for (int i = 0; i < nSamples; i++)
            {
                float w0 = i > 0 ? Mathf.Abs(kernel[i].w - kernel[i - 1].w) : 0.0f;
                float w1 = i < nSamples - 1 ? Mathf.Abs(kernel[i].w - kernel[i + 1].w) : 0.0f;
                float area = (w0 + w1) / 2.0f;
                Vector3 temp = area * profile(kernel[i].w, falloff);
                Vector4 tt = new Vector4(temp.x, temp.y, temp.z, kernel[i].w);
                kernel[i] = tt;
            }

            // We want the offset 0.0 to come first:
            Vector4 t = kernel[nSamples / 2];
            for (int i = nSamples / 2; i > 0; i--)
                kernel[i] = kernel[i - 1];
            kernel[0] = t;

            // Calculate the sum of the weights, we will need to normalize them below:
            Vector3 sum = Vector3.zero;
            for (int i = 0; i < nSamples; i++)
            {
                sum.x += kernel[i].x;
                sum.y += kernel[i].y;
                sum.z += kernel[i].z;
            }
            // Normalize the weights:
            for (int i = 0; i < nSamples; i++)
            {
                Vector4 vecx = kernel[i];
                vecx.x /= sum.x;
                vecx.y /= sum.y;
                vecx.z /= sum.z;
                kernel[i] = vecx;
            }

            // Tweak them using the desired strength. The first one is:
            //     lerp(1.0, kernel[0].rgb, strength)
            Vector4 vec = kernel[0];
            vec.x = (1.0f - strength.x) * 1.0f + strength.x * vec.x;
            vec.y = (1.0f - strength.y) * 1.0f + strength.y * vec.y;
            vec.z = (1.0f - strength.z) * 1.0f + strength.z * vec.z;
            kernel[0] = vec;

            // The others:
            //     lerp(0.0, kernel[0].rgb, strength)
            for (int i = 1; i < nSamples; i++)
            {
                var vect = kernel[i];
                vect.x *= strength.x;
                vect.y *= strength.y;
                vect.z *= strength.z;
                kernel[i] = vect;
            }
        }

        //falloff越大 profile越宽
        private static Vector3 gaussian(float variance, float r, Vector3 falloff)
        {
            Vector3 g;

            float rr1 = r / (0.001f + falloff.x);
            g.x = Mathf.Exp((-(rr1 * rr1)) / (2.0f * variance)) / (2.0f * 3.14f * variance);

            float rr2 = r / (0.001f + falloff.y);
            g.y = Mathf.Exp((-(rr2 * rr2)) / (2.0f * variance)) / (2.0f * 3.14f * variance);

            float rr3 = r / (0.001f + falloff.z);
            g.z = Mathf.Exp((-(rr3 * rr3)) / (2.0f * variance)) / (2.0f * 3.14f * variance);

            return g;
        }
        private static Vector3 profile(float r, Vector3 falloff)
        {
            return 0.100f * gaussian(0.0484f, r, falloff) +
                    0.118f * gaussian(0.187f, r, falloff) +
                    0.113f * gaussian(0.567f, r, falloff) +
                    0.358f * gaussian(1.99f, r, falloff) +
                    0.078f * gaussian(7.41f, r, falloff);
        }
    }
   
```


 # 关键步骤
 预处理的散射效果通过两次模糊绘制后最终计算结果通过SetRenderTarget(m_Diffuse.Identifier())绘制在_SSS_DiffuseTex上核心代码如下：
 ```
var drawSettings = CreateDrawingSettings(shaderTags, ref renderingData, SortingCriteria.CommonOpaque);
context.DrawRenderers(renderingData.cullResults, ref drawSettings, ref filterSettings);

material.EnableKeyword("SSS_DiffuseOnly");
cmd.SetRenderTarget(m_TempH.Identifier());
cmd.SetGlobalTexture("_SourceTex", m_Diffuse.Identifier());
cmd.DrawProcedural(Matrix4x4.identity, material, 0, MeshTopology.Triangles, 3);

cmd.SetRenderTarget(m_Diffuse.Identifier());
cmd.SetGlobalTexture("_SourceTex", m_TempH.Identifier());
cmd.DrawProcedural(Matrix4x4.identity, material, 1, MeshTopology.Triangles, 3); 
 ```
 通常第一个pass（光照模式ForwardLit）需要获取第二个自定义pass计算出的结果（这里是计算散射的pass）需要做prepass操作，这里通过feature可以很方便的让第一个pass拿到_SSS_DiffuseTex信息，在第一个pass中（lit pass）计算屏幕信息，然后通过模板写入来对特定皮肤进行处理。

  
这里之所以需要分两个pass来传递数据是为了使用Separable-sss的卷积核来进行模糊处理的shader核心代码如下：
 ```
for (int i = 1; i < SamplerSteps; i++)
{
    float4 kernelValue = _Kernel[i];
    float2 SSSUV = uv + kernelValue.a * UVOffset;
    
    #if SSS_DiffuseOnly
        float4 SSSSceneColor = SAMPLE_TEXTURE2D(_SourceTex, sampler_PointClamp, SSSUV);
    #else
        float4 SSSSceneColor = SAMPLE_TEXTURE2D(_SourceTex, sampler_LinearClamp, SSSUV);
    #endif

    if(SSSSceneColor.a == 0) SSSSceneColor.rgb = SceneColor.rgb;
    BlurSceneColor.rgb += kernelValue.rgb * SSSSceneColor.rgb;
}

 ``` 
通过prepass计算出基础光照模型需要的散射贴图信息(预计算的散射效果可以选择fast SSS或者其他散射效果进行计算)，再由Separable-sss核函数进行二次一维模糊处理（两次绘制），最后在UniversalForward pass中参与计算。完整代码如下：
 

C#:
```  
    public static class SeparableSSS
    {
        public static void CalculateKernel(List<Vector4> kernel, int nSamples, Vector3 strength, Vector3 falloff)
        {
            float RANGE = nSamples > 20 ? 3.0f : 2.0f;
            float EXPONENT = 2.0f;
            kernel.Clear();

            // Calculate the offsets:
            float step = 2.0f * RANGE / (nSamples - 1);
            for (int i = 0; i < nSamples; i++)
            {
                float o = -RANGE + (float)i * step;
                float sign = o < 0.0f ? -1.0f : 1.0f;
                float w = RANGE * sign * Mathf.Abs(Mathf.Pow(o, EXPONENT)) / Mathf.Pow(RANGE, EXPONENT);
                kernel.Add(new Vector4(0, 0, 0, w));
            }
            // Calculate the weights:
            for (int i = 0; i < nSamples; i++)
            {
                float w0 = i > 0 ? Mathf.Abs(kernel[i].w - kernel[i - 1].w) : 0.0f;
                float w1 = i < nSamples - 1 ? Mathf.Abs(kernel[i].w - kernel[i + 1].w) : 0.0f;
                float area = (w0 + w1) / 2.0f;
                Vector3 temp = area * profile(kernel[i].w, falloff);
                Vector4 tt = new Vector4(temp.x, temp.y, temp.z, kernel[i].w);
                kernel[i] = tt;
            }

            // We want the offset 0.0 to come first:
            Vector4 t = kernel[nSamples / 2];
            for (int i = nSamples / 2; i > 0; i--)
                kernel[i] = kernel[i - 1];
            kernel[0] = t;

            // Calculate the sum of the weights, we will need to normalize them below:
            Vector3 sum = Vector3.zero;
            for (int i = 0; i < nSamples; i++)
            {
                sum.x += kernel[i].x;
                sum.y += kernel[i].y;
                sum.z += kernel[i].z;
            }
            // Normalize the weights:
            for (int i = 0; i < nSamples; i++)
            {
                Vector4 vecx = kernel[i];
                vecx.x /= sum.x;
                vecx.y /= sum.y;
                vecx.z /= sum.z;
                kernel[i] = vecx;
            }

            // Tweak them using the desired strength. The first one is:
            //     lerp(1.0, kernel[0].rgb, strength)
            Vector4 vec = kernel[0];
            vec.x = (1.0f - strength.x) * 1.0f + strength.x * vec.x;
            vec.y = (1.0f - strength.y) * 1.0f + strength.y * vec.y;
            vec.z = (1.0f - strength.z) * 1.0f + strength.z * vec.z;
            kernel[0] = vec;

            // The others:
            //     lerp(0.0, kernel[0].rgb, strength)
            for (int i = 1; i < nSamples; i++)
            {
                var vect = kernel[i];
                vect.x *= strength.x;
                vect.y *= strength.y;
                vect.z *= strength.z;
                kernel[i] = vect;
            }
        }

        //falloff越大 profile越宽
        private static Vector3 gaussian(float variance, float r, Vector3 falloff)
        {
            Vector3 g;

            float rr1 = r / (0.001f + falloff.x);
            g.x = Mathf.Exp((-(rr1 * rr1)) / (2.0f * variance)) / (2.0f * 3.14f * variance);

            float rr2 = r / (0.001f + falloff.y);
            g.y = Mathf.Exp((-(rr2 * rr2)) / (2.0f * variance)) / (2.0f * 3.14f * variance);

            float rr3 = r / (0.001f + falloff.z);
            g.z = Mathf.Exp((-(rr3 * rr3)) / (2.0f * variance)) / (2.0f * 3.14f * variance);

            return g;
        }
        private static Vector3 profile(float r, Vector3 falloff)
        {
            return 0.100f * gaussian(0.0484f, r, falloff) +
                    0.118f * gaussian(0.187f, r, falloff) +
                    0.113f * gaussian(0.567f, r, falloff) +
                    0.358f * gaussian(1.99f, r, falloff) +
                    0.078f * gaussian(7.41f, r, falloff);
        }
    }
    public class SeparableSSSRenderFeature : ScriptableRendererFeature
    {
        public Shader shader;

        SeparableSSSPass _SSSSPass;
        Material material;

       const int sampleCount = 11;//暂时写死11


        public override void Create()
        {
            _SSSSPass = new SeparableSSSPass(this);
        }

        public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
        {
            if (renderingData.cameraData.isSceneViewCamera)
            {
                return;
            }
            if (shader == null)
            {
                Debug.LogWarningFormat("Missing Shader");
                return;
            }

            if (material == null)
            {
                material = new Material(shader);
            }

            var stack = VolumeManager.instance.stack;
            var ss = stack.GetComponent<SeparableSSSComponent>();
            if (ss.IsActive())
            {
                float ssss_fov = 1.0f / (Mathf.Tan(0.5f * (renderingData.cameraData.camera.fieldOfView * Mathf.Deg2Rad)));
                _SSSSPass.Setup(ss, ssss_fov);
                renderer.EnqueuePass(_SSSSPass);
            }
        }

        internal class SeparableSSSPass : ScriptableRenderPass
        {
            private SeparableSSSRenderFeature feature;
            private SeparableSSSComponent _component;
            RenderTargetHandle m_TempH, m_Diffuse, m_DiffuseDepth;
            private List<Vector4> kernel = new List<Vector4>(sampleCount);

            float DistanceToProjectionWindow = 5.671281819617709f;

            public SeparableSSSPass(SeparableSSSRenderFeature feature)
            {
                this.feature = feature;
                m_TempH.Init("TEMP_H");
                m_Diffuse.Init("_SSS_DiffuseTex");
                m_DiffuseDepth.Init("_SSS_DiffuseDepthTex");
            }

            public void CalculateKernel(SeparableSSSComponent data, List<Vector4> kernel)
            {
                Vector3 SSSC = new Vector3(data.SurfaceColor.value.r, data.SurfaceColor.value.g, data.SurfaceColor.value.b);
                Vector3 SSSFC = new Vector3(data.SurfaceFalloff.value.r, data.SurfaceFalloff.value.g, data.SurfaceFalloff.value.b);
                SeparableSSS.CalculateKernel(kernel, sampleCount, SSSC, SSSFC);
            }
            
            public void Setup(SeparableSSSComponent component,float ssss_fov)
            {
                this._component = component;
                this.DistanceToProjectionWindow = ssss_fov;
                CalculateKernel(this._component, kernel);
                this.renderPassEvent = this._component.PreDiffuse.value ? RenderPassEvent.BeforeRenderingOpaques : RenderPassEvent.BeforeRenderingSkybox;
            }

            public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
            {
                var OriginWidth = cameraTextureDescriptor.width;
                var OriginHeight = cameraTextureDescriptor.height;

                var width = OriginWidth;
                var height = OriginHeight;
                if (this._component.PreDiffuse.value)
                {
                    cmd.GetTemporaryRT(m_TempH.id, width, height, 0, FilterMode.Bilinear, GraphicsFormat.R16G16B16A16_SFloat);
                    cmd.GetTemporaryRT(m_Diffuse.id, width, height, 0, FilterMode.Bilinear, GraphicsFormat.R16G16B16A16_SFloat);
                    cmd.GetTemporaryRT(m_DiffuseDepth.id, width, height, 24, FilterMode.Point, RenderTextureFormat.Depth);
                }
                else
                {
                    cmd.GetTemporaryRT(m_TempH.id, width, height, 0, FilterMode.Bilinear, cameraTextureDescriptor.graphicsFormat);
                }
            }

            public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
            {
                var material = feature.material;
                var source = renderingData.cameraData.renderer.cameraColorTarget;
                var depth = renderingData.cameraData.renderer.cameraDepthTarget;
                {
                    CommandBuffer cmd = CommandBufferPool.Get("SeparableSSS");

                    material.SetFloat("_SSSScale", _component.SSSScale.value);
                    material.SetVectorArray("_Kernel", kernel);
                    material.SetFloat("_DistanceToProjectionWindow", DistanceToProjectionWindow);

                    if (this._component.PreDiffuse.value)
                    {
                        CoreUtils.SetKeyword(cmd, "_SSS_BlendDiffuse", true);
                        
                        cmd.SetRenderTarget(m_Diffuse.Identifier(), m_DiffuseDepth.Identifier());
                        cmd.ClearRenderTarget(true, true, new Color(0, 0, 0, 0));
                        context.ExecuteCommandBuffer(cmd);
                        cmd.Clear();
                        var filterSettings = new FilteringSettings(RenderQueueRange.opaque, -1);
                        var shaderTags = new List<ShaderTagId>
                        {
                            new ShaderTagId("SSS_DiffuseOnly")
                        };
                        var drawSettings = CreateDrawingSettings(shaderTags, ref renderingData, SortingCriteria.CommonOpaque);
                        context.DrawRenderers(renderingData.cullResults, ref drawSettings, ref filterSettings);
                        
                        material.EnableKeyword("SSS_DiffuseOnly");
                        cmd.SetRenderTarget(m_TempH.Identifier());
                        cmd.SetGlobalTexture("_SourceTex", m_Diffuse.Identifier());
                        cmd.DrawProcedural(Matrix4x4.identity, material, 0, MeshTopology.Triangles, 3);
                        
                        cmd.SetRenderTarget(m_Diffuse.Identifier());
                        cmd.SetGlobalTexture("_SourceTex", m_TempH.Identifier());
                        cmd.DrawProcedural(Matrix4x4.identity, material, 1, MeshTopology.Triangles, 3);
                        
                        cmd.SetRenderTarget(source, depth);
                        context.ExecuteCommandBuffer(cmd);


                        //脸部效果？？？？《--------------------------------------------------------------------------- 
                        cmd.Clear();
                        shaderTags.Clear();
                        shaderTags.Add(new ShaderTagId("MakeupOutput"));
                        drawSettings = CreateDrawingSettings(shaderTags, ref renderingData, SortingCriteria.CommonOpaque);
                        context.DrawRenderers(renderingData.cullResults, ref drawSettings, ref filterSettings);
                        //---------------------------------------------------------------------------》
                    }
                    else
                    {
                        material.DisableKeyword("SSS_DiffuseOnly");
                        if (this._component.DoublePass.value)
                        {
                            for (int i = 0; i < 2; i++)
                            { 
                                cmd.SetRenderTarget(m_TempH.Identifier());
                                cmd.ClearRenderTarget(false, true, Color.black);
                                cmd.SetGlobalTexture("_SourceTex", source);
                                cmd.DrawProcedural(Matrix4x4.identity, material, 0, MeshTopology.Triangles, 3); 
                                cmd.SetRenderTarget(source, depth);
                                cmd.SetGlobalTexture("_SourceTex", m_TempH.Identifier());
                                cmd.DrawProcedural(Matrix4x4.identity, material, 1, MeshTopology.Triangles, 3);
                            } 
                        }
                        else
                        {  
                            cmd.SetRenderTarget(m_TempH.Identifier());
                            cmd.ClearRenderTarget(false, true, Color.black);
                            cmd.SetGlobalTexture("_SourceTex", source);
                            cmd.DrawProcedural(Matrix4x4.identity, material, 0, MeshTopology.Triangles, 3);
                        
                            cmd.SetRenderTarget(source, depth);
                            cmd.SetGlobalTexture("_SourceTex", m_TempH.Identifier());
                            cmd.DrawProcedural(Matrix4x4.identity, material, 1, MeshTopology.Triangles, 3);
                        }
                    } 
                    context.ExecuteCommandBuffer(cmd);
                    CommandBufferPool.Release(cmd);
                }
            }

            public override void FrameCleanup(CommandBuffer cmd)
            {
                cmd.ReleaseTemporaryRT(m_TempH.id);
                CoreUtils.SetKeyword(cmd, "_SSS_BlendDiffuse", false);
            }
        }
    } 

```
Shader:

```
Shader "Hidden/Universal Render Pipeline/SeparableSSS"
{
    Properties
    {
        [HideInInspector] _MainTex("Base (RGB)", 2D) = "white" {}
    }
    
    HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
		#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
 
		float4 unity_JitterParams;

		SAMPLER(sampler_PointClamp); 
		SAMPLER(sampler_LinearClamp); 
 
        #pragma enable_d3d11_debug_symbols
        #pragma multi_compile _ SSS_DiffuseOnly
        //暂时写死11
        #define SamplerSteps 11 
 
		TEXTURE2D(_SourceTex);
        SAMPLER(sampler_SourceTex);
		float4 _SourceTex_TexelSize;
		TEXTURE2D(_SourceTex2);
		TEXTURE2D(DiffuseDepthTex);
    
        float _Threshold;
        float _Amplify;
        float4 _MaxColor;

		// 1.0 / tan(0.5 * radians(SSSS_FOVY));
		float _DistanceToProjectionWindow;

        TEXTURE2D(_Blur);
        SAMPLER(sampler_Blur);


		float _SSSScale;
		float4 _Kernel[SamplerSteps];

		Texture2D _CameraDepthTexture;
		Texture2D _SSS_DiffuseDepthTex;

    
        struct Attributes
        {
            float4 positionOS       : POSITION;
            float2 uv               : TEXCOORD0;
			uint vertexID : VERTEXID_SEMANTIC;
        };

        struct Varyings
        {
            float2 uv        : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };

        Varyings ProceduralVert(Attributes input)
        {
            Varyings output;
            output.vertex = GetFullScreenTriangleVertexPosition(input.vertexID);
            output.uv = GetFullScreenTriangleTexCoord(input.vertexID);
            return output;
        } 
    
		half4 SSS(float2 uv, float2 dir,float intensity, int2 clipPos)
		{
			//先取出当前像素颜色
			float4 SceneColor = SAMPLE_TEXTURE2D(_SourceTex, sampler_PointClamp, uv);

        	#if SSS_DiffuseOnly
        		float SceneDepth = LinearEyeDepth(_SSS_DiffuseDepthTex.SampleLevel(sampler_PointClamp, uv, 0), _ZBufferParams);
        	#else
				float SceneDepth = LinearEyeDepth(_CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0), _ZBufferParams);
        	#endif
        	
        	
			float BlurLength = _DistanceToProjectionWindow / SceneDepth;

        	#if SSS_DiffuseOnly
        		intensity *= SceneColor.w;
        	#endif
        	
			float2 UVOffset = dir * intensity * BlurLength;

			float4 BlurSceneColor = SceneColor;
			BlurSceneColor.rgb *= _Kernel[0].rgb;

			for (int i = 1; i < SamplerSteps; i++)
			{
				float4 kernelValue = _Kernel[i];
				float2 SSSUV = uv + kernelValue.a * UVOffset;
				
				#if SSS_DiffuseOnly
					float4 SSSSceneColor = SAMPLE_TEXTURE2D(_SourceTex, sampler_PointClamp, SSSUV);
				#else
					float4 SSSSceneColor = SAMPLE_TEXTURE2D(_SourceTex, sampler_LinearClamp, SSSUV);
				#endif

				if(SSSSceneColor.a == 0) SSSSceneColor.rgb = SceneColor.rgb;
				BlurSceneColor.rgb += kernelValue.rgb * SSSSceneColor.rgb;
			}

			return float4(BlurSceneColor.rgb, SceneColor.a);
		}

        half4 blur_h(Varyings input) : SV_Target
		{
			return SSS(input.uv,float2(1.0,0.0),_SSSScale * _SourceTex_TexelSize.x, input.vertex.xy); 
		}
    
        half4 blur_v(Varyings input) : SV_Target
		{
			return SSS(input.uv,float2(0.0,1.0),_SSSScale * _SourceTex_TexelSize.y, input.vertex.xy); 
		}


		half4 Blend(Varyings input) : SV_Target
		{
			return _SourceTex.Load(int3(input.vertex.xy, 0)) + _SourceTex2.Load(int3(input.vertex.xy, 0));
		}

    ENDHLSL
    
    SubShader
    {

        Tags { "RenderType" = "Opaque" }
		Cull OFF ZTest OFF ZWrite OFF
        LOD 200

        Pass
        {
        	Stencil
			{
				ReadMask 240
				Ref  32
				Comp Equal
			}
            Name "Blur Horizontal"
            
            HLSLPROGRAM
                #pragma vertex ProceduralVert
                #pragma fragment blur_h
            ENDHLSL
        }
        
        Pass
        {
        	Stencil
			{
				ReadMask 240
				Ref  32
				Comp Equal
			}
            Name "Blur Vertical"
            
            HLSLPROGRAM
                #pragma vertex ProceduralVert
                #pragma fragment blur_v
            ENDHLSL
        } 
    }
}
 
```

皮肤shader:
```
//人物shader优化
Shader "Custom/Skin_Test"
{
   Properties { 
        //。。。
		 
		_SkinScattering("散射强度控制", Range(0, 2)) = 1
    }
    SubShader { 
         
        Pass 
    	{
            Name "ForwardLit"
            Tags { "LightMode"="UniversalForward" } 
			Stencil
			{
				Ref  32
				Comp Always
				Pass Replace
			}
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            //。。。
    		Texture2D _SSS_DiffuseTex;

            Varyings vert(Attributes input) {
                Varyings output; 
                output.positionCS = TransformWorldToHClip(vertexInput.positionWS);  

                //。。。
                return output;
            }

            half4 frag(Varyings input) : SV_Target {
                //。。。
                
            	#if _SSS_BlendDiffuse//预处理屏幕散射效果（SeparateSSS 提供预计算diffuse贴图）
            		FinalColor = _SSS_DiffuseTex.Load(int3(input.positionCS.xy, 0)); 
            	#endif 

                return float4(FinalColor, 1);
            }
            ENDHLSL
        } 
 
        Pass
    	{
    		Name "SSS_DiffuseOnly"
    		Tags{"LightMode"="SSS_DiffuseOnly"}
    		
    		Blend One Zero
            HLSLPROGRAM
            //。。。
    	
    		#pragma vertex vert
            #pragma fragment frag
    		#pragma target 4.5 
            //。。。
			float _SkinScattering;

    		float3 ScatteringEffect(float Scattering, float ProcessedScattering, float UnclampedNoL)
            {
                float temp7 = (UnclampedNoL + 0.1) * 0.909 + ProcessedScattering;
                float temp = temp7 * 0.5 + 0.5;
                
                 float temp4 = 0.5 - abs(Scattering - 0.5);
                
                float temp2 = Scattering * (1 - temp4);
                
                float3 temp3 = float3(0.875, 0.98900002, 0.99800003) * Scattering + 1 - Scattering;
                
                float3 temp5 = temp4 * float3(0.1, 0.0049999999, 0.0020000001) + temp2 * float3(0.2, 0.017999999, 0.015);
                float3 temp6 = temp4 * float3(0.60000002, 0.2, 0.14) + temp2 * float3(0.5, 0.37, 0.23999999);
                float3 temp8 = temp7 * temp3;

                float3 temp9 = (temp5 * float3(temp7, temp7, temp7)) - temp8;

                temp8 = (1 - temp) * temp5 + temp8;

                temp5 = saturate( temp9 / temp6 + 0.5);

                temp6 = (1 - temp5) * temp5 * temp6;
                float3 result = temp5 * temp9 + temp8 + temp6 * 0.5;
                return result;
            } 

            half4 frag(Varyings input) : SV_Target {
                //。。。 
  
                float Scattering =_SkinScattering;
                float ProcessedScattering = Scattering * (1 - NoV) * (1 - NoV) * 0.5;
            	float3 SunColor = _MainLightColor.rgb;
                float3 ScatteredSunColor = ScatteringEffect(Scattering, ProcessedScattering, UnClampedNoL) * SunColor ; 
                return float4(ScatteredSunColor, Scattering);
            }  
    		ENDHLSL
    	} 
}

```

 
 # 为什么从效果上看只对光照边缘部分产生了散射模糊效果？
 因为卷积操作是检测屏幕中像素点色差，而光照边缘部分颜色差异大所以会有较好的模糊效果，原理和屏幕描边以及高斯模糊效果类似。（在皮肤shader中直接输出纯色便能发现散射效果没有了）

 # 分两次pass计算的目的是什么？
 这里说的两次pass不是模糊操作的两次pass，而是针对单个皮肤效果而言，即常用的Separable-sss方式是直接对屏幕进行操作所以可控性不强，而通过自身的第二个自定义pass来计算散射效果然后再进行模糊处理拿到的贴图信息进行混合散射效果，还可以在第一个Litpass中进一步对散射效果进行校色控制。

