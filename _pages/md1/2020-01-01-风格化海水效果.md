---
title: 《风格化海水效果》
author: DH Wang
date: 1000-01-01
category: TA
layout: post
---


# Title
 
风格化和写实效果可从海浪Ramp贴图和泡沫流动上去区分，一般风格化呈现出的海浪和泡沫比较单一且质感偏硬一点，写实则更无序和柔软一些，Ramp贴图的亮度部分可由色阶控制，流动的泡沫部分则要求更高一点。
下面是做出来的效果图

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/9/8/2.gif)
![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/9/8/3.gif)

 
水的渲染通常分为两个方面: 一是光照着色， 二是波形模拟。

## 着色部分
反射部分的着色，在实现上通常可以由如下几部分组成:

- 高光反射 (模拟太阳、呈现出波光粼粼效果)
- 天空盒反射 (对应的远景)
- 局部反射 (对应近景)

而折射部分的着色，由如下构成:

- 水下物体与光线作用后沿着折射路径返回到眼中的颜色
- 水自身的散射

水对长波(红)吸收强，而对短波(蓝)散射强。因此越深的水，会呈现出越深的蓝色。
而对于浅水渲染，通常可以不考虑水的散射效应。

因此水面的着色公式最终构成如下:

$$
  //颜色+泡沫高光+反射 
  half3 finalColor=clamp( (  C+  cube+  FoamMask*_FoamColor  ).xyz ,0,1)+S;    
 
$$

关于深度的计算有很多地方都会用到，在水体模拟中需要借助深度来区分水的颜色渲染，同时也要借助深度来反算出世界位置来辅助计算场景的独立深度信息，因为直接算出的深度是在视线空间的，比如从俯视和斜视看同一块区域就会显示不同深度信息，而在实际中应该水的深度是稳定的相对世界空间而言的话，所以在计算时用到的是场景深度而非视线深度，伪代码如下：

```
half SceneDepth(float4 Hcspos)
{ 
    //....
    real SceneDepth=SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoTransformScreenSpaceTex(UV)).r; 
    //....

    // Reconstruct the world space positions.
    float3 worldPos = ComputeWorldSpacePosition(UV, SceneDepth, UNITY_MATRIX_I_VP);

    return worldPos.y; 
}
                
```
使用上面的场景深度才不会在不同视角看水的颜色会发生变化，这里有篇文章介绍的挺详细的（https://zhuanlan.zhihu.com/p/92315967），实际算出的深度信息如下：
![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/9/8/depth.png)








### 水波反射和高光

项目使用两张法线贴图混合来模拟水面波动效果。(节俭的情况下，使用一张也可以，配合不同的uv tile和采样方向)对其中一张法线按水平方向移动采样，另一张则按垂直方向移动采样。

``` 
    //法线的世界坐标UV Panner计算 合并插值//
    half2 worldNorUV01 = ( (i.posWorld).xz / _DisturbanceSpeed.z );
    half2 worldNorUV02 = ( (i.posWorld).xz / _DisturbanceSpeed.w );
    half2 worNorPanner01 = ( 1.0 * _Time.y * _NormalSpeed.xy + worldNorUV01);
    half2 worNorPanner02 = ( 1.0 * _Time.y * _NormalSpeed.zw + worldNorUV02);
    half3 worTexNor = half3(( ( (UnpackNormal( tex2D( _NormalMap, TRANSFORM_TEX(worNorPanner01, _NormalMap) ) )).xyz + (UnpackNormal( tex2D( _NormalMap, TRANSFORM_TEX(worNorPanner02, _NormalMap) ) )).xy) /2.0 ) ,0.5);
    half3 N = lerp( half3(0,0,1) , worTexNor , _NormalStrength);
```

高光部分光照模型使用的半兰伯特即可，不过关于调节高光部分的效果却需要将向量转为方向（不是很好调），这里使用了脚本编写的ShaderGUI来辅助调节显得很方便。

![](https://dhwblog-1301640854.cos.ap-chongqing.myqcloud.com/picture/img/21/9/8/s.png)
可以看到，除了高光部分有些许水面波纹效果，没有高光效果的画面两侧基本上是看不出水纹的。而且Blend无法呈现出很亮的效果。天空盒反射的基本原理是根据视线(ViewDir)和水体表面的法线(NormalDir)，通过镜面反射公式，计算出反射向量(ReflectDir)，然后利用反射向量去一个预制作好的环境Cube贴图上取样像素。关于CubeMap可以[参考Unity的文档](https://docs.unity3d.com/Manual/class-Cubemap.html)。

```hlsl
//天空盒采样
half3 SampleSkybox(samplerCUBE cube,float3 normal,float3 viewDir,float smooth){
    float3 adjustNormal = float3(normal);
    adjustNormal.xz /= smooth;
    float3 refDir = reflect(-viewDir,adjustNormal);
    half4 color = texCUBE(cube,refDir);
    return color.rgb;
}
```




### 边缘泡沫
泡沫的计算也是需要借助深度信息，因为在大多数的水体渲染中，白沫都是一个难点。很多相关的论文，都是在物理波形模拟的基础上去做计算的。由于此处我们是ramp贴图实现的伪水波，因此只能通过一些简单的方式去模拟。下面提供一个思路。

首先白沫通常是出现在水流与物体碰撞处，因此大多数出现在水流与物体接触的边缘。因此我们可以通过接触深度检测算法，在水体与物体的接触处生成白沫效果。

我们有O点的世界坐标，同时可以根据深度图重建P'点的世界坐标。通过计算O与P'的距离，就可以简单的判定O点是否位于物体附近。越近则白沫越强。

白沫强度计算函数如下:

```hlsl
  //深度 
  half deltaDepth=MixDepth(i.screenPos,i.pos,_FoamDepth,1);     // 参数默认为1 泡沫 边缘过渡的参数控制（选择两种深度比较）
  half2 Normaloffset=normalDir1.xy*_WaveNorDistrob; 
  half water1 = (tex2D(_MixWaterTex, i.uv0.xy + float2(_WaterSpeed*_Time.x,0)+Normaloffset).g+tex2D(_MixWaterTex, float2(1-i.uv0.y,i.uv0.x) + float2(_WaterSpeed*_Time.x,0)+Normaloffset).g)/2*_FoamDensity;

  half noiseColor = tex2D(_MixWaterTex, i.uv0.zw*_WaveDistrotion).b; 
  half4 waveColor = tex2D(_WaveMixTex, float2(1-min(_WaveBoard, deltaDepth)/_WaveBoard+_WaveRange*sin(_Time.x*_WaveSpeed+noiseColor*_NoiseRange),1)*_RampTiling+Normaloffset);

  waveColor.rgb *= (1-(sin(_Time.x*_WaveSpeed+noiseColor*_NoiseRange)+1)/2)*noiseColor;
  half4 waveColor2 = tex2D(_WaveMixTex, float2(1-min(_WaveBoard, deltaDepth)/_WaveBoard+_WaveRange*sin(_Time.x*_WaveSpeed+_WaveDelta+noiseColor*_NoiseRange),1)*_RampTiling+Normaloffset);
  waveColor2.rgb *= (1-(sin(_Time.x*_WaveSpeed+_WaveDelta+noiseColor*_NoiseRange)+1)/2)*noiseColor;

  half water_A = 1-min(_WaveBoard, deltaDepth)/_WaveBoard; 
  half water_F = min(_FoamBoard, deltaDepth)/_FoamBoard; 
  water_F= water_A*water_F*step(0.25,water_F); 

  half FoamMask =water1*water_F+(waveColor.r+waveColor2.r) * water_A*_WaveDensity; 
  half FoamwaveAlpha=min(_AlphaFade, deltaDepth)/_AlphaFade; 
}
```
pow是为了让distance增加时，白沫快速消淡。_FoamPower则控制了白沫的分布范围大小。

从网上找一张白沫的贴图,实际应用中，我们只需要单通道就行了:

<img src="./Materials/Foam.jpg">
 






## 波形部分
水波动画模拟也可以分很多类型，简单点的直接使用三角函数即可，复杂点牵涉到真实水波的波形可以使用FFT或者波动方程来模拟，这里效果简单直接使用三角函数即可得到很好的效果了。

其他波形可参考这篇（https://zhuanlan.zhihu.com/p/21573239）