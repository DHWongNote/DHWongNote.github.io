---
title: 【UE Tip】C++
author: DH Wang
date:  1000-01-01
category: GAME
layout: post
---

## 关于#Include

#include 后面用""时其中的路径是相对路径的，用<>则没有，之前的理解一直都是项目自己的文件用""，系统标准库的文件用<>，比较表面。一般头文件都会有一个.h后缀，比如#include<stdio.h>，但也经常会有一些头文件没有.h后缀，比如#include <iostream>，这两者的区别是没有.h后缀的是C++标准库的头文件，而有.h后缀的是C标准库的头文件。
 
## Extern标识符

Extern  外部定义标识符，两个文件中存在相同名字的全局变量会报错，使用extern标识其中一个即可。关键字extern可以链接其他cpp中的变量

## TArray访问崩溃
此外还遇到了一个小问题：TArray类型的变量在初始化之前不能使用[index]来访问，只要访问就崩溃。一旦初始化完成就能正常访问。

## 字符冷知识
```
char* Name = "Zhang";
Name[1] = 'b';//汇编时作为常量，不能修改const char[6]"Zhang"
```

## 容器 vector<T> varbs
    emplace_back() 函数是 C++11 新增加的，其功能和 push_back() 相同，都是在容器尾部添加一个元素。

## 获取当前场景中的HUD
当前关卡中默认设置的HUD Class和Actor的关系可通过 UGameplayStatics来获取
```
AMyHUD * hud = Cast<AMyHUD>(UGameplayStatics::GetPlayerController(this, 0)->GetHUD());
```

## UE4 TMap使用的坑

在执行Add方法，若map中已有相同的key，则会将原来的记录先删除，再写为新的值，需要注意的是这里在删除时不会释放原记录所用的内存，所有就导致map中多出一个空行(Invalid),这个时候获取num是不包含这个空行的，然而在用for(auto& element:map)进行遍历时却会遍历到这个空行，所以这里不推荐使用Add，改为使用FindOrAdd，执行这个方法的时候如果map中已经有了相同的key则会返回value的引用，没有的话会新增并返回value的key。

同样，使用Empty清空map的时候也不会释放内存，需要再次调用Compact才能真正清空，消除Invalid行。


## 模板
标识符：<>


# generated.h
既然是C++了，那么生成的代码自然也差不多是.h.cpp的组合。假设我们为类A生成了A.generated.h和A.generated.cpp（按照UE习俗，名字无所谓）。此时A.h一般也都需要Include "A.generated.h"，比如类A的宏标记生成的代码如果想跟A.generated.h里我们生成的代码来个里应外合的话。另一方面，用户对背后的代码生成应该是保持最小惊讶的，用户写下了A.h，他在使用的时候自然也会想include "A.h"，所以这个时候我们的A.generated.h就得找个方式一起安插进来，最方便的方式莫过于直接让A.h include A.generated.h了。那既然每个需要分析的文件最后都会include这么一个*.generated.h，那自然就可以把它本身就当作一种标记了。所以UE目前的方案是每个要分析的文件加上该Include并且规定只能当作最后一个include，因为他也担心会有各种宏定义顺序产生的问题。

## WHy
通过给类、枚举、属性、函数加上特定的宏来标记更多的元数据；二是在有必要的时候这些标记宏甚至也可以安插进生成的代码来合成编译。
## USTRUCT 结构体

```
USTRUCT(BlueprintType)
struct NEWASSET_API FStructMember
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere)
	float FloatValue;
};
```
## UFUNCTION
这个宏的定义主要就是为了加入虚幻的这一套反射系统中,同理UPROPRETY也一样。

为按钮的OnClick事件进行绑定。绑定的本质是指定要执行的函数。在UE4中这样的函数都需要使用UFUNCTION()宏进行修饰，以便可以借助反射机制找到。

## UPROPERTY 暴露属性序列化
可随意组合
几乎所有的UI元素都是指针。并且用UPROPERTY包裹，内部的Meta也非常重要，官方解释：允许开发者访问绑定在这个界面上的控件。

```
UPROPERTY(Meta = (BindWidget))
class UButton* Btn_Test;


UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "FloatingActor")
float RotationSpeed = 20.0f;
 
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Mesh")
USkeletalMeshComponent* GunMeshComponent;

UPROPERTY(VisibleAnywhere)
UStaticMeshComponent* VisualMesh;
	
UPROPERTY(EditDefaultsOnly, Category = "Camera")
TSubclassOf<UCameraShakeBase> LandedCameraShake;
```

## 获取ENUM的displayname

const UEnum* EnumPtr=FindObject<UEnum>(ANY_PACKAGE,TEXT("[the name of enum class]"),true);
FString DisplayNameStr = EnumPtr->GetMetaData(TEXT("DisplayName"), [the variable]);





# TSubclassOf<UClassAType> ClassA
对一般UClassAType做出限制，类似于C#中typeof，方便在BP中赋值操作避免选取其他类UClass
 
```
UPROPERTY(EditDefaultsOnly, Category=Damage)
UClass* DamageType; 
 
UPROPERTY(EditDefaultsOnly, Category=Damage)
TSubclassOf<UDamageType> DamageType;
```



# C++接口函数 UInterface
UInterface->UInteractiveActor  ->Interactive_A->Interactive_B
   
## 1、创建接口
在UE中创建接口函数文件对应有两个类，一个是给引擎识别的用于执行时检测，另一个是给C++内部识别，如下先创建接口文件再执行接口函数
接口文件.h
```
class UInteractiveActor : public UInterface
{ GENERATED_BODY() }; 
 
class IInteractiveActor
{ 
public: 
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Interact")
	void Interact();
}; 
```

## 2、调用接口
调用检测时使用UE识别接口，执行接口使用C++识别接口
```
// implements interface
if(InteractHit.GetActor()->GetClass()->ImplementsInterface(UInteractiveActor::StaticClass()))
{
	IInteractiveActor::Execute_Interact(InteractHit.GetActor());
}
```

## 3、A实现接口直接在头文件重载是不能被蓝图识别需要加宏 
```
//Interactive_A.h
UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Interact")
void Interact();	// prototype declaration
virtual void Interact_Implementation() override;	// actual implementation of our interact method

//Interactive_A.cpp 
void AInteractiveProp::Interact_Implementation()
{ /* Interactive_A Code*/ }
```
## 4、B不需要蓝图编辑可从A中直接重载
```
//Interactive_B.h
virtual void Interact_Implementation() override;
//Interactive_B.cpp
void Interactive_B::Interact_Implementation()
{/*Interactive_B Code*/}
```

## 测试用例
AFunc():使用射线检测碰撞物体是否含有接口并调用
```
if(InteractHit.GetActor()->GetClass()->ImplementsInterface(UInteractiveActor::StaticClass()))
{
	IInteractiveActor::Execute_Interact(InteractHit.GetActor());
}
```
BFunc():遍历全场景，对含有指定接口的对象调用接口函数
```
// iterate over all of our actors
for(TActorIterator<AActor> ActorIterator(GetWorld()); ActorIterator; ++ActorIterator)
{
	AActor* Actor = *ActorIterator; 
	if(Actor && Actor != this && Actor->GetClass()->ImplementsInterface(UInteractiveActor::StaticClass()))
	{ IInteractiveActor::Execute_Interact(Actor); }
}
```
对 Interactive_A 进行AFunc则会输出 Interactive_A Code.
对 Interactive_A 进行BFunc()则会输出 Interactive_B Code，因为 Interactive_B继承自 Interactive_A。
 
# TSubobjectPtr和C++传统指针的区别
主要有以下区别（1和2的前提条件要满足：指针所在的class必须是UObjcct的子类）： 

1，TSubobjectPtr指针是UE4 API里面为C++传统指针(Native C++ Pointer)提供的智能指针。 
当指针指向的对象被Destroy以后，TSubobjectPtr会被自动置零，C++传统指针需要你手动置NULL。

2，如果TSubobjectPtr加上UE4 模版符号：UPROPERTY()，那么该指针可以暴露给UE4编辑器操作；而C++传统指针不可以。

  















































































































# 语法范例
 
## 结构体
```
USTRUCT(BlueprintType)
struct FMeleeCollisionProfile
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FName Enabled;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FName Disabled;

	// default constructor
	FMeleeCollisionProfile()
	{
		Enabled = FName(TEXT("Weapon"));
		Disabled = FName(TEXT("NoCollision"));
	}
};
```
## 枚举
```
UENUM(BlueprintType)
enum class ELogLevel: uint8 {
	TRACE			UMETA(DisplayName = "Trace"),
	DEBUG			UMETA(DisplayName = "Debug"),
	INFO			UMETA(DisplayName = "Info"),
	WARNING			UMETA(DisplayName = "Warning"),
	ERROR			UMETA(DisplayName = "Error")
};
```
## 加载蓝图资源
``` 
	// set default pawn class to our Blueprinted character
	static ConstructorHelpers::FClassFinder<APawn> PlayerPawnBPClass(TEXT("/Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter"));
	if (PlayerPawnBPClass.Class != NULL)
	{
		DefaultPawnClass = PlayerPawnBPClass.Class;
	}

	// load the attack montage
	static ConstructorHelpers::FObjectFinder<UAnimMontage> MeleeFistAttackMontageObject(TEXT("AnimMontage'/Game/TUTORIAL_RESOURCES/Animations/MeleeFistAttackMontage.MeleeFistAttackMontage'"));
	if(MeleeFistAttackMontageObject.Succeeded()) 
	{
		MeleeFistAttackMontage = MeleeFistAttackMontageObject.Object;
	}
```

## 绑定碰撞事件
```
	LeftFistCollisionBox->OnComponentHit.AddDynamic(this, &AUE4Fundamentals01Character::OnAttackHit);
```



### 函数模板
```
#include <iostream>
#include <string>
 
using namespace std;
 
template <typename T>
inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
} 
int main ()
{
 
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max(i, j) << endl; 
 
    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 
 
    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 
 
    return 0;
}
```
### 类模板

```
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>

using namespace std;

template <class T>
class Stack {
private:
	vector<T> elems;     // 元素 

public:
	void push(T const&);  // 入栈
	void pop();               // 出栈
	T top() const;            // 返回栈顶元素
	bool empty() const {       // 如果为空则返回真。
		return elems.empty();
	}
};

template <class T>
void Stack<T>::push(T const& elem)
{
	// 追加传入元素的副本
	elems.push_back(elem);
}

template <class T>
void Stack<T>::pop()
{
	if (elems.empty()) {
		throw out_of_range("Stack<>::pop(): empty stack");
	}
	// 删除最后一个元素
	elems.pop_back();
}

template <class T>
T Stack<T>::top() const
{
	if (elems.empty()) {
		throw out_of_range("Stack<>::top(): empty stack");
	}
	// 返回最后一个元素的副本 
	return elems.back();
}

int main()
{  
	try {
		Stack<int>         intStack;  // int 类型的栈 
		Stack<string> stringStack;    // string 类型的栈 

		// 操作 int 类型的栈 
		intStack.push(7);
		cout << intStack.top() << endl;

		// 操作 string 类型的栈 
		stringStack.push("hello");
		cout << stringStack.top() << std::endl;
		stringStack.pop();
		stringStack.pop();
	}
	catch (exception const& ex) {
		cerr << "Exception: " << ex.what() << endl;
		return -1;
	} 
}
```

