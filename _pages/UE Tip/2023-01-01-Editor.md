---
title: 【UE Tip】Editor
author: DH Wang
date:  1000-01-01
category: GAME
layout: post
---

# CMD执行C++函数
需要使用UFUNCTION(Exec)宏标识，
满足基类：
```
APawn
APlayerController
UPlayerInput
UCheatManager
AGameMode
UGameInstance
AHUD
``` 
# 组件可视化绘制图标
Actor组件如果需要绘制图标需要通过新建ClassA继承FComponentVisualizer类重写DrawVisualization
```
virtual void DrawVisualization(const UActorComponent* Component, const FSceneView* View, FPrimitiveDrawInterface* PDI) override;
```

# 参数面板属性
配合UE4自带的WidgetReflector工具，我们能很快定位各个UI组件的入口，从而方便的“抄”代码，为我所用。

蓝图变量序列化显示Detail   //变量设置Instance Editable

C++变量序列化序列化显示Detail //支持常用类型和枚举类(UENUM)
```
UPROPERTY(EditAnywhere, Category = "Add Items")
float A;
```

# DrawDebugHelpers 绘制函数库
#include "DrawDebugHelpers.h"
```
DrawDebugLine(GetWorld(), START, END, FColor::Green);
 
Primitive形状（Primitive Shapes） 
DrawDebugBox | DrawDebugSphere | DrawDebugCapsule | DrawDebugCylinder | DrawDebugPlane | DrawDebugCone | DrawDebugPoint

固体形状（Solid Shapes） 
DrawDebugSolidBox  | DrawDebugSolid Plane

其他常见形状（Other Common Shapes） 
DrawDebugFrustrum | DrawDebugCamera |    DrawDebugCrosshairs 

网格体（Meshes） 
DrawDebugMesh 
```
## 持久存在：不能每帧执行
绘制出的图标可设置存在时间，持久保存可设置bPersistentLines = true
取消持久绘制出的所有物体可调 FlushPersistentDebugLines(GetWorld());

 

# Inspector Button

custom Event->Call in Editor

# Py调ue窗口
plugins->uE->pymenu.py

# 浮动窗口 Editor Utility Widget
Content->Editor Utility->Editor Utility WIdget
编辑UI后可直接给按钮绑定触发事件


# Toolbar新增按钮


# 资源操作->(AssetFunctions.py)
增删改查、全局dirty保存、创建默认资源、导入导出等

# 常用Editor类
## Python 
本地资源操作：unreal.EditorAssetLibrary


## BP(Editor Utilites->Editor Utility BluePrint)
在UE4中，关卡中的任何对象都是Actor，是Content Browser中、存储在硬盘上的各个Asset的实例化对象；ActorActionUtility和AssetActionUtility决定了脚本是对Actor操作还是Asset操作；

场景Actor:ActorActionUtility


本地资源：AssetActionUtility
1、shift点击蓝图函数进入编辑界面
2、可添加输入参数弹窗

## C++