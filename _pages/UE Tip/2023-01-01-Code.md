---
title: 【UE Tip】Code
author: DH Wang
date:  1000-01-01
category: GAME
layout: post
---

URL: https://docs.unrealengine.com/4.27/en-US/Basics/UnrealEngineForUnityDevs/#compoundobjects

# 类型转换 
```
Collider collider = gameObject.GetComponent<Collider>;
SphereCollider sphereCollider = collider as SphereCollider;
if (sphereCollider != null)
{
        // ...
}
```
```
UPrimitiveComponent* Primitive = MyActor->GetComponentByClass(UPrimitiveComponent::StaticClass());
USphereComponent* SphereCollider = Cast<USphereComponent>(Primitive);
if (SphereCollider != nullptr)
{
        // ...
}
```
# int转化
```
int i=0;
FString ComponentName = TEXT("Comp") + FString::FromInt(i);
```



# Destory 
Destroy(MyGameObject);
Destroy(MyGameObject, 1);

MyActor->Destroy();
MyActor->SetLifeSpan(1);

# 实例化创建

Object::CreateDefaultSubobject
```
UStaticMeshComponent* CurrentComp;
int i=0;
FString ComponentName = TEXT("Comp") + FString::FromInt(i);
// 创建组件时名称不能相同
CurrentComp = CreateDefaultSubobject<UStaticMeshComponent>(FName(*ComponentName));
```
		 

// spawn the projectile at the muzzle
GetWorld()->SpawnActor<AFPSProjectile>(ProjectileClass, MuzzleLocation, MuzzleRotation, ActorSpawnParams);

         
# 禁用 
Unity：MyGameObject.SetActive(false);

C++
```
// Hides visible components

    MyActor->SetActorHiddenInGame(true);

    // Disables collision components
    MyActor->SetActorEnableCollision(false);

    // Stops the Actor from ticking
    MyActor->SetActorTickEnabled(false);
```

# 组件<访问>object 
GameObject ParentGO = MyComponent.gameObject;
MyComponent MyComp = gameObject.GetComponent<MyComponent>(); 

AActor* ParentActor = MyComponent->GetOwner();
UMyComponent* MyComp = MyActor->FindComponentByClass<UMyComponent>();




# UPROPERTY获取属性
```
//遍历一个类的UProperty:
for(TFiledIterator<UProperty>It(/*UClass**/)；It;++It)
{
     UProperty *newProperty=It;
}

//根据属性名字PropertyName获取UProperty
UProperty *foundProperty = FindField<UProperty>(/*UClass**/,TEXT("PropertyName"));

//获取一个对象的某属性值的指针地址
void ValuePtr = foundProperty->ContainerPtrToValuePtr<void*>(Object);

//根据PropertyPath获取属性值
FCachedPropertyPath PropertyPath(FString(TEXT("PropertyName")));
T Value;
ProperthPathHelpers::GetPropertyValue(Object,PropertyPath,Value);

//有获取就有设置
ProperthPathHelpers::SetPropertyValue(Object,PropertyPath,Value);

//还可以获取成String
FString PropertyValueStr;
ProperthPathHelpers::GetPropertyValueAsString(Object,PropertyPath,PropertyValueStr);

//同样，反向也可以
ProperthPathHelpers::SetPropertyValueFromString(Object,PropertyPath,PropertyValueStr);
//实际上，我们平时在UE引擎中复制粘贴属性值就是将属性值获取为String以及从String这只属性值的整个过程。 
```
# Find(name、Type、Tag)
```
// Find GameObject by name
GameObject MyGO = GameObject.Find("MyNamedGameObject");

// Find Objects by type
MyComponent[] Components = Object.FindObjectsOfType(typeof(MyComponent)) as MyComponent[];
foreach (MyComponent Component in Components)
{
        // ...
}

// Find GameObjects by tag
GameObject[] GameObjects = GameObject.FindGameObjectsWithTag("MyTag");
foreach (GameObject GO in GameObjects)
{
        // ...
}




// Find Actor by name (also works on UObjects)
AActor* MyActor = FindObject<AActor>(nullptr, TEXT("MyNamedActor"));

// Find Actors by type (needs a UWorld object)
for (TActorIterator<AMyActor> It(GetWorld()); It; ++It)
{
        AMyActor* MyActor = *It;
        // ...
}
// Find UObjects by type
for (TObjectIterator<UMyObject> It; It; ++It)
{
    UMyObject* MyObject = *It;
    // ...
}

// Find Actors by tag (also works on ActorComponents, use TObjectIterator instead)
for (TActorIterator<AActor> It(GetWorld()); It; ++It)
{
    AActor* Actor = *It;
    if (Actor->ActorHasTag(FName(TEXT("Mytag"))))
    {
        // ...
    }
}
```
# Tag
## Add Tag
ue组件有自身Tag

MyGameObject.tag = "MyTag";


// Actors can have multiple tags
MyActor.Tags.AddUnique(TEXT("MyTag"));
  
// Components have their own array of tags
MyComponent.ComponentTags.AddUnique(TEXT("MyTag"));
## Comparing tag
if (MyGameObject.CompareTag("MyTag"))
{
    // ...
} 



// Checks if an Actor has this tag
if (MyActor->ActorHasTag(FName(TEXT("MyTag"))))
{
    // ...
}
// Checks if an ActorComponent has this tag
if (MyComponent->ComponentHasTag(FName(TEXT("MyTag"))))
{
    // ...
}

# 射线使用
```
GameObject FindGOCameraIsLookingAt()
{
    Vector3 Start = Camera.main.transform.position;
    Vector3 Direction = Camera.main.transform.forward;
    float Distance = 100.0f;
    int LayerBitMask = 1 << LayerMask.NameToLayer("Pawn");

    RaycastHit Hit;
    bool bHit = Physics.Raycast(Start, Direction, out Hit, Distance, LayerBitMask);

    if (bHit)
    {
        return Hit.collider.gameObject;
    }

    return null;
}
```

``` 
APawn* AMyPlayerController::FindPawnCameraIsLookingAt()
{
    // You can use this to customize various properties about the trace
    FCollisionQueryParams Params;
    // Ignore the player's pawn
    Params.AddIgnoredActor(GetPawn());

    // The hit result gets populated by the line trace
    FHitResult Hit;

    // Raycast out from the camera, only collide with pawns (they are on the ECC_Pawn collision channel)
    FVector Start = PlayerCameraManager->GetCameraLocation();
    FVector End = Start + (PlayerCameraManager->GetCameraRotation().Vector() * 1000.0f);
    bool bHit = GetWorld()->LineTraceSingle(Hit, Start, End, ECC_Pawn, Params);

    if (bHit)
    {
        // Hit.Actor contains a weak pointer to the Actor that the trace hit
        return Cast<APawn>(Hit.Actor.Get());
    }

    return nullptr;
}
```

# Trigger
```
public class MyComponent : MonoBehaviour
{
    void Start()
    {
        collider.isTrigger = true;
    }
    void OnTriggerEnter(Collider Other)
    {
        // ...
    }
    void OnTriggerExit(Collider Other)
    {
        // ...
    }
}
```
```
UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()

    // My trigger component
    UPROPERTY()
    UPrimitiveComponent* Trigger;

    AMyActor()
    {
        Trigger = CreateDefaultSubobject<USphereComponent>(TEXT("TriggerCollider"));

        // Both colliders need to have this set to true for events to fire
        Trigger.bGenerateOverlapEvents = true;

        // Set the collision mode for the collider
        // This mode will only enable the collider for raycasts, sweeps, and overlaps
        Trigger.SetCollisionEnabled(ECollisionEnabled::QueryOnly);
    }

    virtual void NotifyActorBeginOverlap(AActor* Other) override;

    virtual void NotifyActorEndOverlap(AActor* Other) override;
};
```


# 刚体锁定
```
public class MyComponent : MonoBehaviour
{
    void Start()
    {
        rigidbody.isKinimatic = true;
        rigidbody.velocity = transform.forward * 10.0f;
    }
}
```

```
UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()

    UPROPERTY()
    UPrimitiveComponent* PhysicalComp;

    AMyActor()
    {
        PhysicalComp = CreateDefaultSubobject<USphereComponent>(TEXT("CollisionAndPhysics"));
        PhysicalComp->SetSimulatePhysics(false);
        PhysicalComp->SetPhysicsLinearVelocity(GetActorRotation().Vector() * 100.0f);
    }
};
```

# 输入检测
```
public class MyPlayerController : MonoBehaviour
{
    void Update()
    {
        if (Input.GetButtonDown("Fire"))
        {
            // ...
        }
        float Horiz = Input.GetAxis("Horizontal");
        float Vert = Input.GetAxis("Vertical");
        // ...
    }
}
```

```
UCLASS()
class AMyPlayerController : public APlayerController
{
    GENERATED_BODY()

    void SetupInputComponent()
    {
        Super::SetupInputComponent();

        InputComponent->BindAction("Fire", IE_Pressed, this, &AMyPlayerController::HandleFireInputEvent);
        InputComponent->BindAxis("Horizontal", this, &AMyPlayerController::HandleHorizontalAxisInputEvent);
        InputComponent->BindAxis("Vertical", this, &AMyPlayerController::HandleVerticalAxisInputEvent);
    }

    void HandleFireInputEvent();
    void HandleHorizontalAxisInputEvent(float Value);
    void HandleVerticalAxisInputEvent(float Value);
};
```

# 右键菜单

if(MouseEvent.GetEffectingButton() == EKeys::RightMouseButton
{
    FMenuBuilder MenuBuilder(true,[CommandList]or[nullptr]);
    MenuBuilder.BeginSection("SectionName",FText("Display Section Name"));
    {
         MenuBuilder.AddMenuEntry(FGenericCommands::Get().Cut);
         MenuBuilder.AddMenuEntry(FText("Displayname"),FText("tooltiptext"),
         FExecuteAction::CreateRaw(this,&fun,[param,]),NAME_NONE,EUserInterfaceActionType::Button);
    }
    MenuBuilder.BeginSection();
    /*添加二级菜单*/
    MenuBuilder.AddSubMenu(FText("Displayname"),FText("tooltiptext"),FNewMenuDelegate::CreateSP(this,&[class::fun/*(FMenuBuilder& MenuBuilder)*/]))
}

# Program 特性
 
.Net Framework ：UE4


String ：FString, FText
List ：TArray
Dictionary ：TMap
HashSet ：TSet