---
title: 【Unity Tip】ShaderTip
author: DH Wang
date:  1000-01-01
category: GAME
layout: post
---

 
# 获取当前的RenderPipeline
GraphicsSettings.currentRenderPipeline as MyUniversalRenderPipelineAsset


# 在openles 上不支持再顶点着色器访问structbuffer

# lightUseLinear  RenderPipelineBatching  RenderingLayerMask
GraphicsSettings.lightsUseLinearIntensity = (QualitySettings.activeColorSpace == ColorSpace.Linear);
//计算Light的最终颜色时  使用该Light的色温 https://docs.unity3d.com/cn/2017.1/ScriptReference/Rendering.GraphicsSettings-lightsUseColorTemperature.html
GraphicsSettings.lightsUseColorTemperature = true;
GraphicsSettings.useScriptableRenderPipelineBatching = asset.useSRPBatcher;
GraphicsSettings.defaultRenderingLayerMask = k_DefaultRenderingLayerMask;


### UnityShader参数面板特性

    ```
    Shader "lcl/ShaderPropertyDrawer/ShaderEnum"
    {
        // 材质属性面常见类型
        Properties
        {
            [Header(Custom)]
            // 自定义枚举
            [Enum(CustomEnum1,1,CustomEnum2,2)]  _CustomEnum ("CustomEnum", Float) = 1

            // 内置枚举
            [Header(Option)]
            [Enum(UnityEngine.Rendering.BlendOp)]  _BlendOp  ("BlendOp", Float) = 0
            [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend ("SrcBlend", Float) = 1
            [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend ("DstBlend", Float) = 0
            [Enum(Off, 0, On, 1)]_ZWriteMode ("ZWriteMode", float) = 1
            [Enum(UnityEngine.Rendering.CullMode)]_CullMode ("CullMode", float) = 2
            [Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode ("ZTestMode", Float) = 4
            [Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask ("ColorMask", Float) = 15

            [Header(Stencil)]
            [Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp ("Stencil Comparison", Float) = 8
            [Enum(UnityEngine.Rendering.StencilOp)]_StencilPass ("Stencil Pass", Float) = 0
            [Enum(UnityEngine.Rendering.StencilOp)]_StencilFail ("Stencil Fail", Float) = 0
            [Enum(UnityEngine.Rendering.StencilOp)]_StencilZFail ("Stencil ZFail", Float) = 0
            // Slider
            [Header(Slider)]
            [IntRange]_StencilWriteMask ("Stencil Write Mask", Range(0,255)) = 255
            [IntRange]_StencilReadMask ("Stencil Read Mask", Range(0,255)) = 255
            [IntRange]_Stencil ("Stencil ID", Range(0,255)) = 0
            [PowerSlider(3.0)] _Shininess ("Shininess", Range (0.01, 1)) = 0.08

            // Toggle
            [Header(Toggle)]
            [Toggle] _Toggle("Toggle", Float) = 0
            [MaterialToggle] _MaterialToggle("Material Toggle", Float) = 0
            
            [Header(KeywordEnum)]
            // 每个选项都将被设置 _OVERLAY_NONE, _OVERLAY_ADD, _OVERLAY_MULTIPLY shader keywords.
            // 配合multi_compile使用 每个名称都将 采用“属性名”+ 下划线 +“枚举名”这种形式的大写着色器关键字。最多可提供 9 个名称。
            [KeywordEnum(None, Add, Multiply)] _Overlay ("Overlay mode", Float) = 0

            // 空间划分
            [Space] _Prop1 ("Prop1", Float) = 0
            [Space(50)] _Prop2 ("Prop2", Float) = 0


            [Header(Texture)]
            // 用来修饰贴图变量，在inspcetor 面板中不再显示该贴图的tilling/offset 属性
            [NoScaleOffset]_MainTex ("No Scale Offset", 2D) = "white" {}
            // 用来修饰贴图变量，该贴图必须是一个法线贴图
            [Normal]_NormalTex ("NormalTex", 2D) = "white" {}
            // 用来修饰贴图变量，该贴图必须是一个high-dynamic range(HDR)贴图
            [HDR]_HDRTex ("HDRTex", 2D) = "white" {}

        }
        SubShader
        {
            Tags { "RenderType"="Opaque" }

            BlendOp [_BlendOp]
            Blend [_SrcBlend] [_DstBlend]
            ZWrite [_ZWriteMode]
            ZTest [_ZTestMode]
            Cull [_CullMode]
            ColorMask [_ColorMask]
            Pass
            {
                Stencil
                {
                    Ref [_Stencil]
                    Comp [_StencilComp]
                    ReadMask [_StencilReadMask]
                    WriteMask [_StencilWriteMask]
                    Pass [_StencilPass]
                    Fail [_StencilFail]
                    ZFail [_StencilZFail]
                }
                CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                // make fog work
                #pragma multi_compile_fog
                // ...later on in CGPROGRAM code:
                #pragma multi_compile _OVERLAY_NONE _OVERLAY_ADD _OVERLAY_MULTIPLY

                #include "UnityCG.cginc"

                struct appdata
                {
                    float4 vertex : POSITION;
                    float2 uv : TEXCOORD0;
                };

                struct v2f
                {
                    float2 uv : TEXCOORD0;
                    UNITY_FOG_COORDS(1)
                    float4 vertex : SV_POSITION;
                };

                sampler2D _MainTex;
                float4 _MainTex_ST;

                v2f vert (appdata v)
                {
                    v2f o;
                    o.vertex = UnityObjectToClipPos(v.vertex);
                    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                    UNITY_TRANSFER_FOG(o,o.vertex);
                    return o;
                }

                fixed4 frag (v2f i) : SV_Target
                {
                    // sample the texture
                    fixed4 col = tex2D(_MainTex, i.uv);
                    // apply fog
                    UNITY_APPLY_FOG(i.fogCoord, col);
                    return col;
                }
                ENDCG
            }
        }
    }


    ```
### semantics
    ## pragma target 3.0:
    fixed4 frag (v2f i, UNITY_VPOS_TYPE screenPos : VPOS) : SV_Target
    fixed4 frag (fixed facing : VFACE) : SV_Target

    ## pragma target 3.5
    ``` 
    uint vid : SV_VertexID // vertex ID, needs to be uint
    uint instanceID : SV_InstanceID



### 获取模型方向、WorldView   
    UNITY_MATRIX_I_V
    half3 worldViewDir = -normalize(UNITY_MATRIX_V[2].xyz);
    half3 modelFrontDir =normalize( unity_WorldToObject[1].xyz);

    float3 Front = lerp(unity_ObjectToWorld._12_22_32, -unity_ObjectToWorld._12_22_32, _FaceShadowMode - 1);
    float3 Left = lerp(unity_ObjectToWorld._13_23_33, -unity_ObjectToWorld._11_21_31, _FaceShadowMode - 1); 
    float3 Right = -Left;

/// <summary>
/// Returns the pivot of the object in world space.
/// </summary>
float3 GetObjectPivot()
{
    #if defined(PER_OBJECT_VALUES_CALCULATED)
        return g_ObjectPivot;
    #else
        return GetAbsolutePositionWS( float3(UNITY_MATRIX_M[0].w, UNITY_MATRIX_M[1].w, UNITY_MATRIX_M[2].w) );
    #endif
}
### 判断平台   
    #ifdef UNITY_UV_STARTS_AT_TOP//判断平台openGL -dx
        i.sspos.y = 1 - i.sspos.y;
    #endif

### 屏幕UV 
    float2 screenUV = i.CSpos.xy*(_ScreenParams.zw-1);


### Cbuffer 设置目标RT 
    ```feature中的一段代码
    public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
    {
        if (RainEffectConfig.Instance.UpdateDepthData)
        {
            cmd.GetTemporaryRT(Uniforms.CastDepthTex, 1024, 1024, 32, FilterMode.Bilinear, RenderTextureFormat.Depth);
            //set the RT as Render Target
            ConfigureTarget(Uniforms.CastDepthTex);
            //ConfigureTarget(Uniforms.CastColorTex, Uniforms.CastDepthTex);
            //clear the RT
            ConfigureClear(ClearFlag.All, Color.black);
            cmd.SetGlobalTexture(Uniforms.CastDepthTex, Uniforms.CastDepthTex);
        }
        else
        {
            ConfigureClear(ClearFlag.None, Color.black);
        }
    }

    private static class Uniforms
    { 
        internal static readonly int CastDepthTex = Shader.PropertyToID("_CastDepthTex");
    }
    ```


### feature开关
    ```
    [Toggle(RED)]_Alphaclip(“镂空"，Float)= 0
    
    #pragma shader_feature RED  
    
    #if RED
        return half4(1,e,e,1);#endif
    #endif 




    [KeywordEnum(Off,On)] _RED("red",Float) = 0

    #pragma multi_compile __ _RED_ON
        
    #if _RED_ON
                return fixed4(1,0,0,1);
    #endif


    ```
### GUI
    ```
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEditor;
    using System.Linq;
    using System;
    public class ColorsGUI : ShaderGUI
    {

        private static bool bRed = false;
        private static bool bGreen = false;
        private static bool bBlue = false;

        public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)
        {
            // render the default gui
            base.OnGUI(materialEditor, properties);

            Material targetMat = materialEditor.target as Material;

            bRed = Array.IndexOf(targetMat.shaderKeywords, "RED") != -1;
            bGreen = Array.IndexOf(targetMat.shaderKeywords, "GREEN") != -1;
            bBlue = Array.IndexOf(targetMat.shaderKeywords, "BLUE") != -1;

            EditorGUI.BeginChangeCheck();

            bRed = EditorGUILayout.Toggle("红", bRed);
            bGreen = EditorGUILayout.Toggle("绿", bGreen);
            bBlue = EditorGUILayout.Toggle("蓝", bBlue);

            if (EditorGUI.EndChangeCheck())
            {
                if (bRed)
                    targetMat.EnableKeyword("RED");
                else
                    targetMat.DisableKeyword("RED");
                if (bGreen)
                    targetMat.EnableKeyword("GREEN");
                else
                    targetMat.DisableKeyword("GREEN");
                if (bBlue)
                    targetMat.EnableKeyword("BLUE");
                else
                    targetMat.DisableKeyword("BLUE");
            }
        }
    }

    ```


### 获取模型中心点世界坐标 

    float3 center = float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);

    float3 center = float3(unity_ObjectToWorld._m03, unity_ObjectToWorld._m13, unity_ObjectToWorld._m23);

    float3 center = mul(unity_ObjectToWorld , float(0,0,0,1)).xyz;

    float3 center = unity_ObjectToWorld._14_24_34;

### 路径

    ```
    #include "Packages/com.h3d.shader/Core/ShaderFramework.hlsl"
    #include "../../URPInclude/H3DURP.hlsl"
    #include "Assets/H3DTech/Script/WindCreator/Shader/WindCommonIncludes.hlsl" 
    ```

### Noise
    ```
    // Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW
	float hash(float p) {
		p = frac(p * 0.011); 
		p *= p + 7.5;
		p *= p + p;
		return frac(p);
	}
	
	float noise(float x) {
		float i = floor(x);
		float f = frac(x);
		float u = f * f * (3.0 - 2.0 * f);
		return lerp(hash(i), hash(i + 1.0), u);
	}
    
    float value1 = mainvalue*noise(frec)*maxmin.x ;
    ```

### 已知两个坐标系构建变换矩阵
    以风场为例，以世界坐标y轴为轴心构建变换矩阵如下：
```
   //构建风场坐标系及转换矩阵
                float3 windforward = winddir;
                float3 windup = float3(0,1,0);
                float3 windcross = cross(windforward,windup); 
                float3x3 Mat_WindtoWorld =float3x3(
                    dot(float3(1,0,0),windforward), dot(float3(0,1,0),windforward), dot(float3(0,0,1),windforward),
                    dot(float3(1,0,0),windup),      dot(float3(0,1,0),windup),      dot(float3(0,0,1),windup),
                    dot(float3(1,0,0),windcross),   dot(float3(0,1,0),windcross),   dot(float3(0,0,1),windcross)
                ); 

```

 